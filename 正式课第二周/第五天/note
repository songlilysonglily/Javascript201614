1.正则由两部分组成：元字符和修饰符
var re=/\d+/g;
2.元字符和修饰符：
有特殊意义的元字符
\ | () . \n \b ^ $
\s \S \d \D \w \W
[a-z][^a-z][abc] [^abc]
代表次数的量词元字符
* + ? {n} {n,} {n,m}
修饰符：g i m
3.正则创建两种方式的区别：
1）字面量创建：1.不需要转义 2.无法进行变量的拼接
2）实例创建：new RegExp('元字符','修饰符')
            1.需要转义 2.可以进行变量拼接
4.[]的用法：
1）在[]中特殊符号，没有特殊含义；
2）在[]中不会出现两位数
5.？的总结：
1）？可有可无；
2）(?:)只匹配不捕获
3) +？：解决正则的贪婪性；
6.正则的方法和属性：正则的两个方法和一个属性
两个方法：
1）re.test() 校验，因为他返回的是布尔值，所以，一般用在if的条件判断语句中
2）re.exec() exec每次只能捕获到一个；如果是数组的话，在没有小分组的情况下，数组的长度是3：
    参1：捕获到的内容
    参2：索引
    参3：input-》原始字符串
    如果有小分组的时候，小分组从参2开始；
一个属性：re.lastIndex:每次开始查找的位置；
7.捕获的方法：
1）re.exec()
2）str.match()：
    在有全局g的情况下，exec能够捕获小分组，match只能捕获大正则的内容，无法捕获小分组
3）str.replace();两个参数：参1：字符串/正则 ; 参2:字符串/匿名函数
   在这个匿名函数中，接收的参数，跟exec拿到的值一模一样；
   匿名函数被调用的次数，取决于前面正则匹配成功的次数；
8.正则捕获的两大特性：
1）懒惰性：每调用一次exec，lastIndex永远都是从0的位置开始查找；
解决措施：添加全局g;就可以实现lastIndex值的增加；
2）贪婪性：如果用了+号，永远拿到是最长的值；
解决措施：+?
9.()的用法：
1）在正则中，有/^(18|19)$/时，加()提高优先级；
2）分组的作用
3）(?:) 只匹配，不捕获；
10.谁能够影响lastIndex的值？
re.test()
re.exec()
以上两个都必须配合g，才能实现lastIndex值的增加；
11.回调函数注意4点：
1）什么时候被调用？调用次数？
2）是否传参
3）是否改变this指向
4）是否有返回值；





